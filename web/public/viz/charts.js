// Interactive Charts using Chart.js
// Fetches real data from CSV files generated by the analysis

document.addEventListener('DOMContentLoaded', function () {
    // Helper function to parse CSV text
    function parseCSV(csvText) {
        const lines = csvText.trim().split(/\r?\n/); // Handle both \n and \r\n
        const headers = lines[0].split(',').map(h => h.trim());
        return lines.slice(1).map(line => {
            const values = line.split(','); // Simple split, assumes no commas in values for now
            return headers.reduce((obj, header, index) => {
                obj[header] = values[index] ? values[index].trim() : '';
                return obj;
            }, {});
        });
    }

    // 1. Top Hub Videos Chart
    async function initTopHubsChart() {
        const ctx = document.getElementById('topHubsChart');
        if (!ctx) return;

        try {
            const response = await fetch('data/top_hub_videos_degree.csv');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const csvText = await response.text();
            const data = parseCSV(csvText);
            console.log("Successfully loaded Top Hubs data");

            // Process data: Take top 10
            const top10 = data.slice(0, 10);
            const labels = top10.map(d => {
                // Truncate title if too long and remove quotes if present
                let title = d.title ? d.title.replace(/^"|"$/g, '') : 'Unknown';
                return title.length > 30 ? title.substring(0, 30) + '...' : title;
            });
            const values = top10.map(d => parseInt(d.metric_value));

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Network Degree',
                        data: values,
                        backgroundColor: 'rgba(255, 59, 48, 0.7)', // Red
                        borderColor: 'rgba(255, 59, 48, 1)',
                        borderWidth: 1,
                        borderRadius: 4
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { family: 'system-ui' },
                            bodyFont: { family: 'system-ui' }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: 'rgba(255, 255, 255, 0.7)', font: { family: 'system-ui' } }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: 'rgba(255, 255, 255, 0.9)', font: { family: 'system-ui' } }
                        }
                    }
                }
            });
        } catch (error) {
            console.error("Error loading Top Hubs data:", error);
        }
    }

    // 2. Engagement Overview Chart
    async function initEngagementChart() {
        const ctx = document.getElementById('engagementChart');
        if (!ctx) return;

        try {
            // Fetch both likes and replies data to calculate totals
            const [likesRes, repliesRes] = await Promise.all([
                fetch('data/eda_likes_distribution.csv'),
                fetch('data/eda_replies_distribution.csv')
            ]);

            if (!likesRes.ok) throw new Error(`Likes HTTP error! status: ${likesRes.status}`);
            if (!repliesRes.ok) throw new Error(`Replies HTTP error! status: ${repliesRes.status}`);

            const likesText = await likesRes.text();
            const repliesText = await repliesRes.text();
            console.log("Successfully loaded Engagement data");

            const likesData = parseCSV(likesText);
            const repliesData = parseCSV(repliesText);

            // Calculate totals (sum of count * value)
            // Note: The CSVs are distributions (value, count). 
            // Total = sum(value * count)

            const totalLikes = likesData.reduce((sum, row) => sum + (parseInt(row.likes) * parseInt(row.count)), 0);
            const totalReplies = repliesData.reduce((sum, row) => sum + (parseInt(row.replies) * parseInt(row.count)), 0);

            // Update the text in the HTML
            const likesEl = document.querySelector('li:first-child strong');
            const repliesEl = document.querySelector('li:last-child strong');
            if (likesEl) likesEl.nextSibling.textContent = ` ${(totalLikes / 1000000).toFixed(1)} Million`;
            if (repliesEl) repliesEl.nextSibling.textContent = ` ${(totalReplies / 1000000).toFixed(1)} Million`;

            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Likes', 'Replies'],
                    datasets: [{
                        data: [totalLikes, totalReplies],
                        backgroundColor: [
                            'rgba(255, 59, 48, 0.8)', // Red
                            'rgba(255, 255, 255, 0.2)' // White/Glass
                        ],
                        borderColor: 'rgba(0, 0, 0, 0)',
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: 'rgba(255, 255, 255, 0.8)', font: { family: 'system-ui' } }
                        }
                    },
                    cutout: '70%'
                }
            });

        } catch (error) {
            console.error("Error loading Engagement data:", error);
        }
    }

    // 3. Part 1: Power Law Charts (Video Popularity & User Activity)
    async function initPowerLawCharts() {
        try {
            const [videoRes, userRes] = await Promise.all([
                fetch('data/eda_video_popularity.csv'),
                fetch('data/eda_user_activity.csv')
            ]);

            if (!videoRes.ok) throw new Error(`Video HTTP error! status: ${videoRes.status}`);
            if (!userRes.ok) throw new Error(`User HTTP error! status: ${userRes.status}`);

            const videoData = parseCSV(await videoRes.text());
            const userData = parseCSV(await userRes.text());
            console.log("Successfully loaded Power Law data");

            // Video Popularity
            const videoCtx = document.getElementById('videoPopularityChart');
            if (videoCtx) {
                new Chart(videoCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Videos',
                            data: videoData.map(d => ({ x: parseInt(d.comments_per_video), y: parseInt(d.video_count) })),
                            backgroundColor: 'rgba(255, 59, 48, 0.5)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'logarithmic', title: { display: true, text: 'Comments per Video' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } },
                            y: { type: 'logarithmic', title: { display: true, text: 'Count of Videos' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            }

            // User Activity
            const userCtx = document.getElementById('userActivityChart');
            if (userCtx) {
                new Chart(userCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Users',
                            data: userData.map(d => ({ x: parseInt(d.comments_per_user), y: parseInt(d.user_count) })),
                            backgroundColor: 'rgba(52, 199, 89, 0.5)' // Green
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'logarithmic', title: { display: true, text: 'Comments per User' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } },
                            y: { type: 'logarithmic', title: { display: true, text: 'Count of Users' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            }
        } catch (error) {
            console.error("Error loading Power Law data:", error);
        }
    }

    // 4. Part 1: Cumulative Distribution Charts
    async function initCumulativeCharts() {
        const ctx = document.getElementById('cumulativeChart');
        if (!ctx) return;

        try {
            const [videoRes, userRes] = await Promise.all([
                fetch('data/eda_cumulative_video.csv'),
                fetch('data/eda_cumulative_user.csv')
            ]);

            if (!videoRes.ok) throw new Error(`Video HTTP error! status: ${videoRes.status}`);
            if (!userRes.ok) throw new Error(`User HTTP error! status: ${userRes.status}`);

            const videoData = parseCSV(await videoRes.text());
            const userData = parseCSV(await userRes.text());
            console.log("Successfully loaded Cumulative data");

            // Downsample for performance if needed (taking every 100th point for smoother rendering if large)
            // Assuming data is reasonably sized or we take a subset
            const step = Math.ceil(videoData.length / 1000);

            const videoPoints = videoData.filter((_, i) => i % step === 0).map(d => ({ x: parseInt(d.video_rank), y: parseFloat(d.cumulative_pct) }));
            const userPoints = userData.filter((_, i) => i % step === 0).map(d => ({ x: parseInt(d.user_rank), y: parseFloat(d.cumulative_pct) }));

            new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Videos',
                            data: videoPoints,
                            borderColor: 'rgba(255, 59, 48, 1)',
                            borderWidth: 2,
                            pointRadius: 0
                        },
                        {
                            label: 'Users',
                            data: userPoints,
                            borderColor: 'rgba(52, 199, 89, 1)',
                            borderWidth: 2,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Rank' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } },
                        y: { title: { display: true, text: 'Cumulative %' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } }
                    },
                    plugins: { legend: { labels: { color: 'white' } } }
                }
            });

        } catch (error) {
            console.error("Error loading Cumulative data:", error);
        }
    }

    // 5. Part 2: Network Charts (Degree Distribution & Component Sizes)
    async function initNetworkCharts() {
        try {
            const [degreeRes, compRes] = await Promise.all([
                fetch('data/network_degree_distribution.csv'),
                fetch('data/network_component_sizes.csv')
            ]);

            if (!degreeRes.ok) throw new Error(`Degree HTTP error! status: ${degreeRes.status}`);
            if (!compRes.ok) throw new Error(`Component HTTP error! status: ${compRes.status}`);

            const degreeData = parseCSV(await degreeRes.text());
            const compData = parseCSV(await compRes.text());
            console.log("Successfully loaded Network data");

            // Degree Distribution
            const degreeCtx = document.getElementById('degreeDistributionChart');
            if (degreeCtx) {
                new Chart(degreeCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Degree',
                            data: degreeData.map(d => ({ x: parseInt(d.degree), y: parseInt(d.count) })).filter(p => p.x > 0), // Log scale can't handle 0
                            backgroundColor: 'rgba(10, 132, 255, 0.5)' // Blue
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'logarithmic', title: { display: true, text: 'Degree' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } },
                            y: { type: 'logarithmic', title: { display: true, text: 'Count' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            }

            // Component Sizes
            const compCtx = document.getElementById('componentSizeChart');
            if (compCtx) {
                new Chart(compCtx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Components',
                            data: compData.map(d => ({ x: parseInt(d.rank), y: parseInt(d.size) })),
                            backgroundColor: 'rgba(255, 214, 10, 0.5)' // Yellow
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { type: 'logarithmic', title: { display: true, text: 'Rank' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } },
                            y: { type: 'logarithmic', title: { display: true, text: 'Size' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: 'rgba(255,255,255,0.7)' } }
                        },
                        plugins: { legend: { display: false } }
                    }
                });
            }

        } catch (error) {
            console.error("Error loading Network data:", error);
        }
    }

    // 6. Part 3: Top Hubs Betweenness
    async function initHubsBetweennessChart() {
        const ctx = document.getElementById('topHubsBetweennessChart');
        if (!ctx) return;

        try {
            const response = await fetch('data/top_hub_videos_betweenness.csv');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = parseCSV(await response.text());
            console.log("Successfully loaded Top Hubs Betweenness data");

            // Process data: Take top 10
            const top10 = data.slice(0, 10);
            const labels = top10.map(d => {
                let title = d.title ? d.title.replace(/^"|"$/g, '') : 'Unknown';
                return title.length > 30 ? title.substring(0, 30) + '...' : title;
            });
            const values = top10.map(d => parseFloat(d.metric_value));

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Betweenness Centrality',
                        data: values,
                        backgroundColor: 'rgba(191, 90, 242, 0.7)', // Purple
                        borderColor: 'rgba(191, 90, 242, 1)',
                        borderWidth: 1,
                        borderRadius: 4
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { family: 'system-ui' },
                            bodyFont: { family: 'system-ui' }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: 'rgba(255, 255, 255, 0.7)', font: { family: 'system-ui' } }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: 'rgba(255, 255, 255, 0.9)', font: { family: 'system-ui' } }
                        }
                    }
                }
            });
        } catch (error) {
            console.error("Error loading Top Hubs Betweenness data:", error);
        }
    }

    // Initialize
    initTopHubsChart();
    initEngagementChart();
    initPowerLawCharts();
    initCumulativeCharts();
    initNetworkCharts();
    initHubsBetweennessChart();
});
